// ==UserScript==
// @name         YouTube Toggle Translation for French, German, Russian, Ukrainian
// @namespace    http://tampermonkey.net/
// @version      1.3
// @license      Unlicense
// @author       Jim Chen
// @homepage     https://jimchen.me
// @match        https://www.youtube.com/*
// @match        https://m.youtube.com/*
// @run-at       document-idle
// ==/UserScript==
(function () {
  "use strict";
  let lastUrl = location.href;
  let processingSubtitles = false;
  const observer = new MutationObserver(() => {
    if (location.href !== lastUrl) {
      lastUrl = location.href;
      handleVideoNavigation();
    }
  });
  observer.observe(document.body, { childList: true, subtree: true });
  handleVideoNavigation();

  async function handleVideoNavigation() {
    if (processingSubtitles == true) return;
    processingSubtitles = true;
    let subtitleURL = await extractSubtitleUrl();
    if (subtitleURL == null) return;
    // removeSubs();
    // await addOneSubtitle(subtitleURL + "&tlang=en");
    await addOneSubtitle(subtitleURL);
    processingSubtitles = false;
  }

  async function extractSubtitleUrl() {
    function extractYouTubeVideoID() {
      const url = window.location.href;
      const patterns = {
        standard: /(?:https?:\/\/)?(?:www\.)?youtube\.com\/watch\?v=([^&]+)/,
        embed: /(?:https?:\/\/)?(?:www\.)?youtube\.com\/embed\/([^?]+)/,
        mobile: /(?:https?:\/\/)?(?:www\.)?youtu\.be\/([^?]+)/,
      };

      let videoID = null;

      if (patterns.standard.test(url)) {
        videoID = url.match(patterns.standard)[1];
      } else if (patterns.embed.test(url)) {
        videoID = url.match(patterns.embed)[1];
      } else if (patterns.mobile.test(url)) {
        videoID = url.match(patterns.mobile)[1];
      }

      return videoID;
    }
    let videoID = extractYouTubeVideoID();
    if (videoID == null) return;

    const playerData = await new Promise((resolve) => {
      const checkForPlayer = () => {
        let ytAppData = document.querySelector("#movie_player");
        let captionData = ytAppData?.getPlayerResponse()?.captions?.playerCaptionsTracklistRenderer?.captionTracks;
        if (captionData) {
          const fetchedBaseUrl = captionData[0].baseUrl;
          const fetchedVideoID = fetchedBaseUrl.match(/[?&]v=([^&]+)/)?.[1];
          if (fetchedVideoID !== videoID) setTimeout(checkForPlayer, 1000);
          else resolve(captionData);
        } else setTimeout(checkForPlayer, 1000);
      };
      checkForPlayer();
    });

    if (!playerData) return;
    const hasForeignTrack = playerData.some(({ vssId }) => /(ru|uk|de|fr)/.test(vssId));
    if (hasForeignTrack) {
      const autoGeneratedTrack = playerData.find((track) => ["a.ru", "a.uk", "a.de", "a.fr"].includes(track.vssId));
      const manualTrack = playerData.find((track) => ["ru", "uk", "de", "fr"].some((code) => track.vssId.includes(code)));
      const otherTrack = autoGeneratedTrack || manualTrack;
      if (!otherTrack) return;
      return `${otherTrack.baseUrl}&fmt=vtt`;
    }
  }

  async function addOneSubtitle(url, maxRetries = 5, delay = 1000) {
    // Step 1. Parse VTT
    // Step 2. Create HTML Element
    // Step 3. Set up Event Listener
    // Step 4. Display Subtitle
    // Step 5. Add Translation

    let currentVideo = null;
    currentVideo = document.querySelector("video");
    if (!currentVideo) return;

    try {
      // Step 1 - Parse VTT
      // Example:

      // 00:00:00.480 --> 00:00:02.950 align:start position:0%
      // [музыка]
      // в<00:00:00.640><c> тот</c><00:00:00.799><c> день</c><00:00:01.000><c> КСИ</c><00:00:01.439><c> решила</c><00:00:01.800><c> встать</c><00:00:02.080><c> в</c><00:00:02.200><c> 4</c><00:00:02.639><c> утра</c>

      // 00:00:02.950 --> 00:00:02.960 align:start position:0%
      // в тот день КСИ решила встать в 4 утра

      // 00:00:02.960 --> 00:00:05.869 align:start position:0%
      // в тот день КСИ решила встать в 4 утра
      // чтобы<00:00:03.240><c> подготовиться</c><00:00:03.840><c> к</c>

      // 00:00:05.869 --> 00:00:05.879 align:start position:0%
      // чтобы подготовиться к

      // Processed like:

      // Start: 00:00:00.480 End: 00:00:02.950
      // Textlines[0]: [музыка]
      //  Textlines[1]: в<00:00:00.640><c> тот</c><00:00:00.799><c> день</c><00:00:01.000><c> КСИ</c><00:00:01.439><c> решила</c><00:00:01.800><c> встать</c><00:00:02.080><c> в</c><00:00:02.200><c> 4</c><00:00:02.639><c> утра</c>

      // Start: 00:00:02.950 End: 00:00:02.960
      // Textlines[0]:  в тот день КСИ решила встать в 4 утра

      // Start: 00:00:02.960 End: 00:00:05.869
      // Textlines[0]:  в тот день КСИ решила встать в 4 утра

      //  Textlines[1]:  чтобы<00:00:03.240><c> подготовиться</c><00:00:03.840><c> к</c>

      // Start: 00:00:05.869 End: 00:00:05.879
      // Textlines[0]: чтобы подготовиться к

      console.log(`[Dual Subs] Starting Step 1, Subtitle URL ${url}`);
      const response = await fetch(url);
      const subtitleData = await response.text();

      // Convert timestamp string (e.g., "00:00:02.950") to seconds
      function parseVTTTime(timeStr) {
        const parts = timeStr.split(/[:.]/); // Split on : and . (simpler than /[:,\.]/ since comma isn't used)
        const hours = parseInt(parts[0], 10);
        const minutes = parseInt(parts[1], 10);
        const seconds = parseInt(parts[2], 10);
        const milliseconds = parseInt(parts[3], 10);
        return hours * 3600 + minutes * 60 + seconds + milliseconds / 1000;
      }

      // Parse VTT content into a structured queue
      function parseVTT(subtitleData) {
        const subtitleQueue = [];
        const lines = subtitleData.trim().split("\n");
        let i = 0;

        // Skip header (e.g., "WEBVTT" or other metadata)
        while (i < lines.length && !lines[i].includes("-->")) {
          i++;
        }

        // Process subtitle blocks
        while (i < lines.length) {
          const line = lines[i].trim();

          if (!line) {
            i++;
            continue;
          }

          // Look for timestamp line
          const timeMatch = line.match(/(\d+:\d+:\d+\.\d+)\s+-->\s+(\d+:\d+:\d+\.\d+)/);
          if (timeMatch) {
            const start = parseVTTTime(timeMatch[1]);
            const end = parseVTTTime(timeMatch[2]);
            const textLines = [];
            i++;

            // Collect all text lines until next empty line or end
            while (i < lines.length && lines[i].trim()) {
              textLines.push(lines[i].trim());
              i++;
            }

            if (textLines.length > 0) {
              subtitleQueue.push({
                start,
                end,
                textLines,
              });
            }
          } else {
            i++; // Skip malformed or unexpected lines
          }
        }

        return subtitleQueue;
      }

      var subtitleQueue = parseVTT(subtitleData);

      // Step 2 - Create HTML Element
      // Example:
      // <div class="caption-window ytp-caption-window-bottom" id="caption-window-_52" dir="ltr" tabindex="0" draggable="true" style="touch-action: none; background-color: rgba(8, 8, 8, 0.25); text-align: center; left: 50%; width: 511px; margin-left: -255.5px; bottom: 2%;">
      //   <span class="captions-text" style="overflow-wrap: normal; display: block;">
      //     <span class="caption-visual-line" style="display: block;">
      //       <span class="ytp-caption-segment" style="display: inline-block; white-space: pre-wrap; background: rgba(8, 8, 8, 0.75); font-size: 25.475px; color: rgb(255, 255, 255); fill: rgb(255, 255, 255);">если он отключит Starlink, мы с вами&nbsp;</span>
      //     </span>
      //   </span>
      // </div>
      // from Language Reactor
      // Add Sliding Effect
      // `coloredSpan.style.cssText`
      // #ffffff 50% for subtitles displayed,  #888888 for upcoming subtitles
      // `animation: slideColor 10s linear` the sliding time

      console.log(`[Dual Subs] Starting Step 2, Trying to Insert Subtitle Element`);
      function createCaptionWindow() {
        const videoPlayer = document.querySelector(".html5-video-player");
        if (!videoPlayer) {
          console.error("HTML5 video player not found");
          return null;
        }

        const captionWindow = document.createElement("div");
        captionWindow.className = "caption-window ytp-caption-window-bottom";
        captionWindow.dir = "ltr";
        captionWindow.tabIndex = 0;
        captionWindow.draggable = true;
        captionWindow.style.cssText = `
                touch-action: none;
                background-color: rgba(8, 8, 8, 0.25);
                text-align: center;
                left: 50%;
                width: 511px;
                margin-left: -255.5px;
                bottom: 2%;
            `;

        const captionsText = document.createElement("span");
        captionsText.className = "captions-text";
        captionsText.style.cssText = "overflow-wrap: normal; display: block;";

        const captionVisualLine = document.createElement("span");
        captionVisualLine.className = "caption-visual-line";
        captionVisualLine.style.cssText = "display: block;";

        const ytpCaptionSegment = document.createElement("span");
        ytpCaptionSegment.className = "ytp-caption-segment";
        ytpCaptionSegment.style.cssText = `
                display: inline-block;
                white-space: pre-wrap;
                background: rgba(8, 8, 8, 0.75);
                font-size: 25.475px;
                color: rgb(255, 255, 255);
                fill: rgb(255, 255, 255);
                position: relative;
            `;

        const textContent = "Userscript for Subtitles Starting";
        const coloredSpan = document.createElement("span");
        coloredSpan.textContent = textContent;
        coloredSpan.style.cssText = `
                background: linear-gradient(to right, #ffffff 50%, #888888 50%);
                background-size: 200% 100%;
                background-position: 100%;
                color: transparent;
                background-clip: text;
                -webkit-background-clip: text;
                animation: slideColor 10s linear infinite;
            `;

        const styleSheet = document.createElement("style");
        styleSheet.textContent = `
                @keyframes slideColor {
                    0% { background-position: 100%; }
                    100% { background-position: 0%; }
                }
            `;
        document.head.appendChild(styleSheet);

        ytpCaptionSegment.appendChild(coloredSpan);
        captionVisualLine.appendChild(ytpCaptionSegment);
        captionsText.appendChild(captionVisualLine);
        captionWindow.appendChild(captionsText);
        videoPlayer.appendChild(captionWindow);

        return ytpCaptionSegment;
      }

      var ytpCaptionSegment = createCaptionWindow();
      if (!ytpCaptionSegment) return;

      // Step 3 - Setup Event Listener for Subtitle Time Change

      function setupTimeUpdateListener() {
        currentVideo.addEventListener("timeupdate", () => {
          const currentTime = currentVideo.currentTime;
          const currentSubtitle = subtitleQueue.find((sub) => currentTime >= sub.start && currentTime <= sub.end);
          updateSubtitle(currentSubtitle);
        });
      }
      setupTimeUpdateListener();

      // Step 4 - Display Subtitle
      console.log(`[Dual Subs] Starting Step 4, Trying to Insert the Subtitles into the Elements Created`);

      function updateSubtitle(currentSubtitle) {
        while (ytpCaptionSegment.firstChild) ytpCaptionSegment.removeChild(ytpCaptionSegment.firstChild);

        if (!currentSubtitle) {
          ytpCaptionSegment.style.display = "none";
          return;
        }

        ytpCaptionSegment.style.display = "inline-block";

        currentSubtitle.textLines.forEach((line, lineIndex) => {
          const lineSpan = document.createElement("span");
          lineSpan.style.display = "block";

          if (line.includes("<c>")) {
            const currentTime = currentVideo.currentTime;
            const timeTagRegex = /<(\d{2}:\d{2}:\d{2}\.\d{3})><c>(.*?)<\/c>/g;
            let matches = [];
            let match;
            let lastIndex = 0;
            let wordArray = [];
            let timeArray = [];

            // Parse the line into words and timestamps
            while ((match = timeTagRegex.exec(line)) !== null) {
              const timeStr = match[1];
              const text = match[2];
              const time = parseVTTTime(timeStr);

              if (match.index > lastIndex) {
                const untaggedText = line.slice(lastIndex, match.index).trim();
                if (untaggedText) {
                  wordArray.push(untaggedText);
                  timeArray.push(currentSubtitle.start);
                }
              }

              wordArray.push(text);
              timeArray.push(time);
              matches.push({ time, text });
              lastIndex = timeTagRegex.lastIndex;
            }

            if (lastIndex < line.length) {
              const untaggedText = line.slice(lastIndex).trim();
              if (untaggedText) {
                wordArray.push(untaggedText);
                timeArray.push(currentSubtitle.start);
              }
            }

            // Animation pointer
            let currentWordIndex = 0;
            for (let i = 0; i < wordArray.length; i++) {
              if (currentTime >= timeArray[i]) {
                currentWordIndex = i;
              } else {
                break;
              }
            }

            // Render words with animation for current word only
            wordArray.forEach((word, index) => {
              const wordSpan = document.createElement("span");
              wordSpan.textContent = word + " ";

              if (index < currentWordIndex) {
                // Past words - fully white
                wordSpan.style.color = "#ffffff";
              } else if (index === currentWordIndex && currentTime >= timeArray[index]) {
                // Current word - animating
                const startTime = timeArray[index];
                const endTime = index + 1 < timeArray.length ? timeArray[index + 1] : currentSubtitle.end;
                const progress = (currentTime - startTime) / (endTime - startTime);

                wordSpan.style.cssText = `
                            background: linear-gradient(to right, #ffffff 50%, #888888 50%);
                            background-size: 200% 100%;
                            background-position: ${100 - progress * 100}%;
                            color: transparent;
                            background-clip: text;
                            -webkit-background-clip: text;
                            transition: background-position 0.1s linear;
                        `;
              } else {
                // Future words - grey
                wordSpan.style.color = "#888888";
              }

              lineSpan.appendChild(wordSpan);
            });
          } else {
            // Lines without <c> tags - display in solid white without animation
            const wordSpan = document.createElement("span");
            wordSpan.textContent = line;
            wordSpan.style.color = "#ffffff";
            lineSpan.appendChild(wordSpan);
          }

          ytpCaptionSegment.appendChild(lineSpan);
        });
      }

      // Step 5 - Add Hover Effect with Translation
      // For each word, not sentence
      // Add an eventlistener to Subtitles Hovering
      console.log(`[Dual Subs] Starting Step 5, Adding Hover Translation Effect`);
    } catch (error) {
      if (maxRetries > 0) {
        await new Promise((resolve) => setTimeout(resolve, delay));
        return addOneSubtitle(url, maxRetries - 1, delay);
      }
    }
  }
})();
