// ==UserScript==
// @name         YouTube Dual Subtitles for French, German, Russian, Ukrainian
// @namespace    http://tampermonkey.net/
// @version      1.3
// @license      Unlicense
// @description  Add dual subtitles to YouTube videos
// @author       Jim Chen
// @homepage     https://jimchen.me
// @match        https://www.youtube.com/*
// @match        https://m.youtube.com/*
// @run-at       document-idle
// ==/UserScript==
(function () {
  "use strict";
  let lastUrl = location.href;
  let processingSubtitles = false;
  const observer = new MutationObserver(() => {
    if (location.href !== lastUrl) {
      lastUrl = location.href;
      handleVideoNavigation();
    }
  });
  observer.observe(document.body, { childList: true, subtree: true });
  handleVideoNavigation();

  async function handleVideoNavigation() {
    if (processingSubtitles == true) return;
    processingSubtitles = true;
    let subtitleURL = await extractSubtitleUrl();
    if (subtitleURL == null) return;
    // removeSubs();
    // await addOneSubtitle(subtitleURL + "&tlang=en");
    await addOneSubtitle(subtitleURL);
    processingSubtitles = false;
  }

  async function extractSubtitleUrl() {
    function extractYouTubeVideoID() {
      const url = window.location.href;
      const patterns = {
        standard: /(?:https?:\/\/)?(?:www\.)?youtube\.com\/watch\?v=([^&]+)/,
        embed: /(?:https?:\/\/)?(?:www\.)?youtube\.com\/embed\/([^?]+)/,
        mobile: /(?:https?:\/\/)?(?:www\.)?youtu\.be\/([^?]+)/,
      };

      let videoID = null;

      if (patterns.standard.test(url)) {
        videoID = url.match(patterns.standard)[1];
      } else if (patterns.embed.test(url)) {
        videoID = url.match(patterns.embed)[1];
      } else if (patterns.mobile.test(url)) {
        videoID = url.match(patterns.mobile)[1];
      }

      return videoID;
    }
    let videoID = extractYouTubeVideoID();
    if (videoID == null) return;

    const playerData = await new Promise((resolve) => {
      const checkForPlayer = () => {
        let ytAppData = document.querySelector("#movie_player");
        let captionData = ytAppData?.getPlayerResponse()?.captions?.playerCaptionsTracklistRenderer?.captionTracks;
        if (captionData) {
          const fetchedBaseUrl = captionData[0].baseUrl;
          const fetchedVideoID = fetchedBaseUrl.match(/[?&]v=([^&]+)/)?.[1];
          if (fetchedVideoID !== videoID) setTimeout(checkForPlayer, 1000);
          else resolve(captionData);
        } else setTimeout(checkForPlayer, 1000);
      };
      checkForPlayer();
    });

    if (!playerData) return;
    const hasForeignTrack = playerData.some(({ vssId }) => /(ru|uk|de|fr)/.test(vssId));
    if (hasForeignTrack) {
      const autoGeneratedTrack = playerData.find((track) => ["a.ru", "a.uk", "a.de", "a.fr"].includes(track.vssId));
      const manualTrack = playerData.find((track) => ["ru", "uk", "de", "fr"].some((code) => track.vssId.includes(code)));
      const otherTrack = autoGeneratedTrack || manualTrack;
      if (!otherTrack) return;
      return `${otherTrack.baseUrl}&fmt=vtt`;
    }
  }

  async function addOneSubtitle(url, maxRetries = 5, delay = 1000) {
    // 1. Parse VTT
    // 2. Create HTML Element
    // 3. Display Subtitle
    // 4. Add Translation

    let currentVideo = null;
    currentVideo = document.querySelector("video");
    if (!currentVideo) return;

    try {
      // Step 1 - Parse VTT (unchanged)
      // Example:

      // 00:00:00.480 --> 00:00:02.950 align:start position:0%
      // [музыка]
      // в<00:00:00.640><c> тот</c><00:00:00.799><c> день</c><00:00:01.000><c> КСИ</c><00:00:01.439><c> решила</c><00:00:01.800><c> встать</c><00:00:02.080><c> в</c><00:00:02.200><c> 4</c><00:00:02.639><c> утра</c>

      // 00:00:02.950 --> 00:00:02.960 align:start position:0%
      // в тот день КСИ решила встать в 4 утра

      // 00:00:02.960 --> 00:00:05.869 align:start position:0%
      // в тот день КСИ решила встать в 4 утра
      // чтобы<00:00:03.240><c> подготовиться</c><00:00:03.840><c> к</c>

      // 00:00:05.869 --> 00:00:05.879 align:start position:0%
      // чтобы подготовиться к

      // Processed like:

      // Start: 00:00:00.480 End: 00:00:02.950
      // Textlines[0]: [музыка]
      //  Textlines[1]: в<00:00:00.640><c> тот</c><00:00:00.799><c> день</c><00:00:01.000><c> КСИ</c><00:00:01.439><c> решила</c><00:00:01.800><c> встать</c><00:00:02.080><c> в</c><00:00:02.200><c> 4</c><00:00:02.639><c> утра</c>

      // Start: 00:00:02.950 End: 00:00:02.960
      // Textlines[0]:  в тот день КСИ решила встать в 4 утра

      // Start: 00:00:02.960 End: 00:00:05.869
      // Textlines[0]:  в тот день КСИ решила встать в 4 утра

      //  Textlines[1]:  чтобы<00:00:03.240><c> подготовиться</c><00:00:03.840><c> к</c>

      // Start: 00:00:05.869 End: 00:00:05.879
      // Textlines[0]: чтобы подготовиться к

      console.log(`[Dual Subs] Starting Step 1, Subtitle URL ${url}`);
      const response = await fetch(url);
      const subtitleData = await response.text();

      // Convert timestamp string (e.g., "00:00:02.950") to seconds
      function parseVTTTime(timeStr) {
        const parts = timeStr.split(/[:.]/); // Split on : and . (simpler than /[:,\.]/ since comma isn't used)
        const hours = parseInt(parts[0], 10);
        const minutes = parseInt(parts[1], 10);
        const seconds = parseInt(parts[2], 10);
        const milliseconds = parseInt(parts[3], 10);
        return hours * 3600 + minutes * 60 + seconds + milliseconds / 1000;
      }

      // Parse VTT content into a structured queue
      function parseVTT(subtitleData) {
        const subtitleQueue = [];
        const lines = subtitleData.trim().split("\n");
        let i = 0;

        // Skip header (e.g., "WEBVTT" or other metadata)
        while (i < lines.length && !lines[i].includes("-->")) {
          i++;
        }

        // Process subtitle blocks
        while (i < lines.length) {
          const line = lines[i].trim();

          if (!line) {
            i++;
            continue;
          }

          // Look for timestamp line
          const timeMatch = line.match(/(\d+:\d+:\d+\.\d+)\s+-->\s+(\d+:\d+:\d+\.\d+)/);
          if (timeMatch) {
            const start = parseVTTTime(timeMatch[1]);
            const end = parseVTTTime(timeMatch[2]);
            const textLines = [];
            i++;

            // Collect all text lines until next empty line or end
            while (i < lines.length && lines[i].trim()) {
              textLines.push(lines[i].trim());
              i++;
            }

            if (textLines.length > 0) {
              subtitleQueue.push({
                start,
                end,
                textLines,
              });
            }
          } else {
            i++; // Skip malformed or unexpected lines
          }
        }

        return subtitleQueue;
      }

      var subtitleQueue = parseVTT(subtitleData);
      console.log(subtitleQueue);

      // Step 2 - Create HTML Element
      // Example:
      // <div class="caption-window ytp-caption-window-bottom" id="caption-window-_52" dir="ltr" tabindex="0" draggable="true" style="touch-action: none; background-color: rgba(8, 8, 8, 0.25); text-align: center; left: 50%; width: 511px; margin-left: -255.5px; bottom: 2%;">
      //   <span class="captions-text" style="overflow-wrap: normal; display: block;">
      //     <span class="caption-visual-line" style="display: block;">
      //       <span class="ytp-caption-segment" style="display: inline-block; white-space: pre-wrap; background: rgba(8, 8, 8, 0.75); font-size: 25.475px; color: rgb(255, 255, 255); fill: rgb(255, 255, 255);">если он отключит Starlink, мы с вами&nbsp;</span>
      //     </span>
      //   </span>
      // </div>
      // from Language Reactor
      // Add Sliding Effect

      console.log(`[Dual Subs] Starting Step 2, Trying to Insert Subtitle Element`);
      function createCaptionWindow() {
        const videoPlayer = document.querySelector(".html5-video-player");
        if (!videoPlayer) {
          console.error("HTML5 video player not found");
          return null;
        }

        const captionWindow = document.createElement("div");
        captionWindow.className = "caption-window ytp-caption-window-bottom";
        captionWindow.dir = "ltr";
        captionWindow.tabIndex = 0;
        captionWindow.draggable = true;
        captionWindow.style.cssText = `
                touch-action: none;
                background-color: rgba(8, 8, 8, 0.25);
                text-align: center;
                left: 50%;
                width: 511px;
                margin-left: -255.5px;
                bottom: 2%;
            `;

        const captionsText = document.createElement("span");
        captionsText.className = "captions-text";
        captionsText.style.cssText = "overflow-wrap: normal; display: block;";

        const captionVisualLine = document.createElement("span");
        captionVisualLine.className = "caption-visual-line";
        captionVisualLine.style.cssText = "display: block;";

        const ytpCaptionSegment = document.createElement("span");
        ytpCaptionSegment.className = "ytp-caption-segment";
        ytpCaptionSegment.style.cssText = `
                display: inline-block;
                white-space: pre-wrap;
                background: rgba(8, 8, 8, 0.75);
                font-size: 25.475px;
                color: rgb(255, 255, 255);
                fill: rgb(255, 255, 255);
                position: relative;
            `;

        const textContent = "Userscript for Subtitles Starting";
        const coloredSpan = document.createElement("span");
        coloredSpan.textContent = textContent;
        coloredSpan.style.cssText = `
                background: linear-gradient(to right, #FFFDD0 0%, #FFFDD0 50%, #ffffff 50%, #ffffff 100%);
                background-size: 200% 100%;
                background-position: 100%;
                color: transparent;
                background-clip: text;
                -webkit-background-clip: text;
                animation: slideColor 3s linear infinite;
            `;

        const styleSheet = document.createElement("style");
        styleSheet.textContent = `
                @keyframes slideColor {
                    0% { background-position: 100%; }
                    100% { background-position: 0%; }
                }
            `;
        document.head.appendChild(styleSheet);

        ytpCaptionSegment.appendChild(coloredSpan);
        captionVisualLine.appendChild(ytpCaptionSegment);
        captionsText.appendChild(captionVisualLine);
        captionWindow.appendChild(captionsText);
        videoPlayer.appendChild(captionWindow);

        return ytpCaptionSegment;
      }

      var ytpCaptionSegment = createCaptionWindow();

      // Step 3 - Display Subtitle
      console.log(`[Dual Subs] Starting Step 3, Trying to Insert the Subtitles into the Elements Created`);
      function updateSubtitle(currentSubtitle) {
        if (!ytpCaptionSegment) return;

        while (ytpCaptionSegment.firstChild) {
          ytpCaptionSegment.removeChild(ytpCaptionSegment.firstChild);
        }

        if (currentSubtitle) {
          console.log(`[Dual Subs] currentSubtitle: ${currentSubtitle.textLines.join(" | ")}`);
          ytpCaptionSegment.style.display = "inline-block";

          currentSubtitle.textLines.forEach((line, lineIndex) => {
            const lineSpan = document.createElement("span");
            lineSpan.style.display = "block";

            if (line.includes("<c>")) {
              const currentTime = currentVideo.currentTime;
              const timeTagRegex = /<(\d{2}:\d{2}:\d{2}\.\d{3})><c>(.*?)<\/c>/g;
              let matches = [];
              let match;
              let lastIndex = 0;

              while ((match = timeTagRegex.exec(line)) !== null) {
                const timeStr = match[1];
                const text = match[2];
                const time = parseVTTTime(timeStr);

                if (match.index > lastIndex) {
                  const untaggedText = line.slice(lastIndex, match.index).trim();
                  if (untaggedText) {
                    const untaggedSpan = document.createElement("span");
                    untaggedSpan.textContent = untaggedText;

                    const firstTagTime = matches.length === 0 ? time : matches[0].time;
                    if (currentTime >= firstTagTime) {
                      untaggedSpan.style.color = "#FFFDD0";
                    } else if (currentTime > currentSubtitle.start) {
                      const duration = firstTagTime - currentSubtitle.start;
                      const progress = (currentTime - currentSubtitle.start) / duration;
                      untaggedSpan.style.cssText = `
                                            background-size: 100% 100%;
                                            color: transparent;
                                            background-clip: text;
                                            -webkit-background-clip: text;
                                            transition: background-position 0.1s linear;
                                        `;
                    }
                    lineSpan.appendChild(untaggedSpan);
                    lineSpan.appendChild(document.createTextNode(" "));
                  }
                }

                matches.push({ time, text, index: match.index });
                lastIndex = timeTagRegex.lastIndex;
              }

              if (lastIndex < line.length) {
                const untaggedText = line.slice(lastIndex).trim();
                if (untaggedText) {
                  const untaggedSpan = document.createElement("span");
                  untaggedSpan.textContent = untaggedText;
                  lineSpan.appendChild(untaggedSpan);
                  lineSpan.appendChild(document.createTextNode(" "));
                }
              }

              matches.sort((a, b) => a.time - b.time);

              for (let i = 0; i < matches.length; i++) {
                const { time, text } = matches[i];
                const nextTime = i < matches.length - 1 ? matches[i + 1].time : currentSubtitle.end;

                const span = document.createElement("span");
                span.textContent = text;
                console.log(`[Dual Subs] text: ${text}`);

                if (currentTime >= time && currentTime < nextTime) {
                  span.style.cssText = `
                                    background: linear-gradient(to right, #FFFDD0 0%, #FFFDD0 50%, #ffffff 50%, #ffffff 100%);
                                    background-size: 200% 100%;
                                    background-position: ${((currentTime - time) / (nextTime - time)) * 100}%;
                                    color: transparent;
                                    background-clip: text;
                                    -webkit-background-clip: text;
                                    transition: background-position 0.1s linear;
                                `;
                } else if (currentTime >= nextTime) {
                  span.style.color = "#FFFDD0";
                }

                lineSpan.appendChild(span);
                lineSpan.appendChild(document.createTextNode(" "));
              }
            } else {
              lineSpan.textContent = line;
            }

            ytpCaptionSegment.appendChild(lineSpan);
          });
        } else {
          ytpCaptionSegment.style.display = "none";
        }
      }

      function setupTimeUpdateListener() {
        currentVideo.addEventListener("timeupdate", () => {
          const currentTime = currentVideo.currentTime;
          const currentSubtitle = subtitleQueue.find((sub) => currentTime >= sub.start && currentTime <= sub.end);
          updateSubtitle(currentSubtitle);
        });
      }

      setupTimeUpdateListener();

      // Step 4 - Add Hover Effect with Translation
      console.log(`[Dual Subs] Starting Step 4, Adding Hover Translation Effect`);
      function addHoverTranslation() {
        const captionSegment = document.querySelector(".ytp-caption-segment");
        if (!captionSegment) {
          console.error("[Dual Subs] Caption segment not found for translation setup");
          return;
        }

        // Function to translate text to English using Google Translate API
        async function translateToEnglish(text) {
          try {
            const response = await fetch(`https://translate.googleapis.com/translate_a/single?client=gtx&sl=auto&tl=en&dt=t&q=${encodeURIComponent(text)}`);
            const data = await response.json();
            return data[0][0][0]; // Extract translated text
          } catch (error) {
            console.error("[Dual Subs] Translation error:", error);
            return "Translation failed";
          }
        }

        // Add hover functionality to the entire caption segment
        let tooltip = null;

        captionSegment.addEventListener("mouseenter", async function () {
          const originalText = this.textContent.trim();
          const translation = await translateToEnglish(originalText);

          // Create tooltip
          tooltip = document.createElement("div");
          tooltip.textContent = translation;
          tooltip.style.cssText = `
                    position: absolute;
                    background: rgba(0, 0, 0, 0.9);
                    color: white;
                    padding: 5px 10px;
                    border-radius: 3px;
                    font-size: 14px;
                    bottom: 100%;
                    left: 50%;
                    transform: translateX(-50%);
                    z-index: 1000;
                    white-space: nowrap;
                `;
          this.appendChild(tooltip);
        });

        captionSegment.addEventListener("mouseleave", function () {
          if (tooltip) {
            tooltip.remove();
            tooltip = null;
          }
        });

        // Style the caption segment to indicate it's hoverable
        captionSegment.style.cursor = "pointer";
      }

      addHoverTranslation();
    } catch (error) {
      if (maxRetries > 0) {
        await new Promise((resolve) => setTimeout(resolve, delay));
        return addOneSubtitle(url, maxRetries - 1, delay);
      }
    }
  }
})();
